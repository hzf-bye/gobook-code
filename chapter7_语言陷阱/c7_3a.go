package main

/*
(1) r是函数的有名返回值，分配在枝上，其地址又被称为返回值所在栈区。首先r被初 始化为 0。
(2)“return O”会复制 0到返回值栈区，返回值 r被赋值为 O
(3)执行 defer语句，由于匿名函数对返回值 r是闭包引用，所以 r++执行后，函数返回值 被修改为1
 */
func f1() (r int)  {

	defer func() {
		r++
	}()
	return 0
}

/*
(1)返回值 r被初始化为 0。
(2)引入局部变量 t， 并初始化为 5,
(3)复制 t的值 5 到返回值 r所在的栈区。
(4) defer语句后面的匿名函数是对局部变量 t的闭包引用， t的值被设置为 10。
(5)函数返回，此时函数返回值战区上的值仍然是 5。
 */
func f2() (r int)  {

	t := 5
	defer func() {
		t = t + 5
	}()
	return t
}

/*
(1)返回值 r被初始化为 0。
(2)复制 1 到 函数返回值 r所在的栈区。
(3)执行 defer, defer 后匿名函数使用的是传参数调用 ，在注册 defer 函数时将函数返回 值 r作为实参传进去，由于函数调用的是值拷贝，所以 defer 函数执行后只是形参值变为 5，对 实参没有任何影响。
(4)函数返回，此时函数返回值战区上的值是 1。
 */
func f3() (r int)  {

	defer func(r int) {
		r = r + 5
	}(r)
	return 1
}

/*
综上所述，对于带 defer 的函数返回整体上有三个步骤 。
(1)执行 return 的值拷贝，将 return语句返回的值复制到函数返回值战区(如果只有一个 return，不带任何变量或值，则此步骤不做任何动作) 。
(2)执行 defer语句，多个defer按照 FILO顺序执行。
(3)执行调整RET指令。
如果对函数调用是值拷贝、函数闭包及 defer 的特性有了解，以及对上面的三条规则熟悉， 那么对于这类函数就不应该再有疑惑了 。
当然在 defer 中修改函数返回值不是一种明智的编程方 法，在实际编程中应尽可能避免此种情况。
还有一种彻底解决该问题的方法是，在定义函数时 使用不带返回值名的格式 。
通过这种方式，defer就不能直接引用返回值的栈区，也就避免了返 回值被修改的问题，看一下下面的f4 f5 。
 */

func f4() int  {

	r := 0
	defer func() {
		r++
	}()
	return r
}

func f5() int  {

	r := 0
	defer func(i int) {
		i++
	}(r)
	return r
}


func main() {

	println("f1=", f1()) //1
	println("f2=", f2()) //5
	println("f3=", f3()) //1
	println("f4=", f4()) //0
	println("f5=", f5()) //0

}